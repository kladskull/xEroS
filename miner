#!/usr/bin/php
<?php declare(strict_types=1);

namespace Xeros;

use cli\Arguments;
use Exception;

define('PROGRAM', 'Miner');
include 'bootstrap.php';

$account = new Account();
$block = new Block();
$pow = new Pow();
$miner = new Miner();
$queue = new Queue();

// command line args
$strict = in_array('--strict', $_SERVER['argv']);
$arguments = new Arguments(compact('strict'));

// set args
$arguments->addFlag(['version', 'v'], 'Display the version');
$arguments->addFlag(['help', 'h'], 'Show this help screen');
$arguments->addFlag(['create-keypair', 'c'], [
    'description' => 'Creates a new rsa keypair, and uses it to mine. Default behaviour is to just use the latest keypair created.'
]);
$arguments->addFlag(['developer'], [
    'description' => 'This is a destructive command, never use it.',
]);

// parse the arguments
$arguments->parse();

if ($arguments['help']) {
    echo $arguments->getHelpScreen();
    exit(0);
}

if ($arguments['version']) {
    echo 'Version: ', Config::getVersion(), PHP_EOL;
    exit(0);
}

$forceMining = false;
if ($arguments['developer']) {
    Console::log('********************************************************************************************');
    Console::log('* ');
    Console::log('* WARNING!!! Forcing the miner to just use local data without a completed blockchain sync...');
    Console::log('* ');
    Console::log('********************************************************************************************');
    $forceMining = true;
}

// use the newest key pair
$acct = $account->getNewestAccount();
if ($acct === null || $arguments['create-keypair']) {
    // do we need to create a new key pair?
    $id = $account->create();
    $acct = $account->get($id);
}
$publicKey = $acct['public_key'];
$privateKey = $acct['private_key'];

// if there is no state, we're likely needing to sync from the network
$store = new DataStore();
$state = $store->getKey('state', '');
if ($state !== 'mine' && $forceMining === false) {
    Console::log('Synchronization is required before mining may begin.');
    exit(0);
}

while (1) {
    $nonce = 0;
    $height = $block->getCurrentHeight() + 1;
    $candidateBlock = $block->getCandidateBlock($height, $publicKey, $privateKey);
    $blockHeader = $block->generateBlockHeader($candidateBlock);

    // inner loop, only exit on an event
    while (1) {
        // assembled the block, now find a hash
        $result = $miner->mineBlock($blockHeader, $candidateBlock['difficulty'], $height, $nonce);

        // something changed
        if ($result['result'] === false && empty($result['nonce'])) {
            break;
        }

        // hash found
        if ($result['result'] === true && !empty($result['nonce'])) {
            $candidateBlock['nonce'] = dechex($result['nonce']);
            $candidateBlock['hash'] = $result['hash'];
            $verified = $pow->verifyPow($result['hash'], $blockHeader, dechex($result['nonce']));

            if ($verified) {
                Console::log('Block proof of work accepted for new block');
                try {
                    $result = $block->validateFullBlock($candidateBlock);
                    if ($result['validated']) {
                        Console::log('***** NEW BLOCK FOUND *****');
                        Console::log('Storing new block with block id ' . $candidateBlock['block_id']);

                        // store and accept locally
                        $block->add($candidateBlock);
                        $block->acceptBlock($candidateBlock['block_id'], $candidateBlock['height']);

                        // add queue item to send it out
                        $queue->add('new_block', $candidateBlock['block_id']);
                        break;
                    }
                } catch (Exception $e) {
                    Console::log('Exception in miner: ' . $e->getMessage());
                }
            }
        }
    }
}